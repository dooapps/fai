// AUTO-GENERATED FILE. DO NOT EDIT.
// Generated by ffigen.

// AUTO GENERATED FILE, DO NOT EDIT.
//
// Generated by `package:ffigen`.
// ignore_for_file: type=lint
@ffi.DefaultAsset('fai_assets')
library;

import 'dart:ffi' as ffi;

/// \brief
/// Descriptografa ID e retorna `u64`
@ffi.Native<ffi.Uint64 Function(slice_ref_uint8_t, slice_ref_uint8_t)>()
external int fbbl_decrypt_id(
  slice_ref_uint8_t data,
  slice_ref_uint8_t nonce,
);

/// \brief
/// Criptografa ID retornando buffer para C
@ffi.Native<FbblBuffer_t Function(ffi.Uint64, slice_ref_uint8_t)>()
external FbblBuffer_t fbbl_encrypt_id(
  int id,
  slice_ref_uint8_t nonce,
);

/// \brief
/// Libera o buffer retornado por `fbbl_encrypt_id`
@ffi.Native<ffi.Void Function(FbblBuffer_t)>()
external void fbbl_free_buffer(
  FbblBuffer_t buf,
);

/// \brief
/// Gera hash numérico seguro
@ffi.Native<ffi.Uint64 Function(ffi.Pointer<ffi.Char>)>()
external int fbbl_generate_numeric_hash(
  ffi.Pointer<ffi.Char> input,
);

/// \brief
/// Inicializa o protector com chave hex de 32 bytes
@ffi.Native<ffi.Int32 Function(ffi.Pointer<ffi.Char>)>()
external int fbbl_initialize(
  ffi.Pointer<ffi.Char> hex_key,
);

/// \brief
/// `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
///
/// # C layout (for some given type T)
///
/// ```c
/// typedef struct {
/// // Cannot be NULL
/// T * ptr;
/// size_t len;
/// } slice_T;
/// ```
///
/// # Nullable pointer?
///
/// If you want to support the above typedef, but where the `ptr` field is
/// allowed to be `NULL` (with the contents of `len` then being undefined)
/// use the `Option< slice_ptr<_> >` type.
final class slice_ref_uint8 extends ffi.Struct {
  /// \brief
  /// Pointer to the first element (if any).
  external ffi.Pointer<ffi.Uint8> ptr;

  /// \brief
  /// Element count
  @ffi.Size()
  external int len;
}

/// \brief
/// `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
///
/// # C layout (for some given type T)
///
/// ```c
/// typedef struct {
/// // Cannot be NULL
/// T * ptr;
/// size_t len;
/// } slice_T;
/// ```
///
/// # Nullable pointer?
///
/// If you want to support the above typedef, but where the `ptr` field is
/// allowed to be `NULL` (with the contents of `len` then being undefined)
/// use the `Option< slice_ptr<_> >` type.
typedef slice_ref_uint8_t = slice_ref_uint8;

/// \brief
/// Buffer contendo dados alocados em Rust, para liberaçãopor C
final class FbblBuffer extends ffi.Struct {
  /// <No documentation available>
  external ffi.Pointer<ffi.Uint8> ptr;

  /// <No documentation available>
  @ffi.Size()
  external int len;
}

/// \brief
/// Buffer contendo dados alocados em Rust, para liberaçãopor C
typedef FbblBuffer_t = FbblBuffer;
